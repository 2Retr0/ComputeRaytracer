#version 450

#define PI       3.14159265359
#define INFINITY 3.402823466e+38

#define MAT_LAMBERTIAN 1
#define MAT_METAL      2
#define MAT_DIELECTRIC 3

#define NUM_SAMPLES 1
#define MAX_BOUNCES 10

#define BAD_INDEX 0xFFFFFFFF

layout (local_size_x = 16, local_size_y = 16) in;

layout (binding = 0, rgba32f) uniform image2D outImage;

struct Material {
    vec3 albedo;
    float fuzziness;
    uint type;
};

struct Sphere {
    vec3 center;
    float radius;
    Material material;
};

struct AABB {
    vec3 min;
    float pad; // Don't use!
    vec3 max;
};

struct BVHNode {
    AABB aabb;
    uint objectBufferIndex;
    uint hitIndex;
    uint missIndex;
};

layout (binding = 1) uniform CameraParameters {
    vec3 position;
    float pad; // Don't use!
    vec3 backward;
    float lensRadius;
    vec3 right;
    float focusDistance;
    vec3 up;
    float iteration;
    vec3 horizontal;
    float seed;
    vec3 vertical;
    uint sphereCount;
    uint bvhSize;
    bool shouldRenderAABB;
} camera;

layout (std140, binding = 2) readonly buffer Spheres {
    Sphere spheres[];
};

layout (std140, binding = 3) readonly buffer BoundingVolumeHierarchy {
    BVHNode bvh[];
};



// Source: Quality hashes collection - nimitz
// https://www.shadertoy.com/view/Xt3cDn
float hashSeed = camera.seed * dot(gl_GlobalInvocationID.xy, gl_GlobalInvocationID.yx);

uint base_hash(uvec2 seed) {
    seed = 1103515245U * ((seed >> 1U) ^ (seed.yx));
    uint h32 = 1103515245U * ((seed.x) ^ (seed.y >> 3U));
    return h32 ^ (h32 >> 16);
}

float hash_1(inout float seed) {
    uint n = base_hash(floatBitsToUint(vec2(seed += 0.1, seed += 0.1)));
    return float(n) * (1.0 / float(0xffffffffU));
}

vec2 hash_2(inout float seed) {
    uint n = base_hash(floatBitsToUint(vec2(seed += 0.1, seed += 0.1)));
    uvec2 rz = uvec2(n, n * 48271U);
    return vec2(rz.xy & uvec2(0x7fffffffU)) / float(0x7fffffff);
}

vec3 hash_3(inout float seed) {
    uint n = base_hash(floatBitsToUint(vec2(seed += 0.1, seed += 0.1)));
    uvec3 rz = uvec3(n, n * 16807U, n * 48271U);
    return vec3(rz & uvec3(0x7fffffffU)) / float(0x7fffffff);
}

vec2 random_in_unit_disk(inout float seed) {
    vec2 h = hash_2(seed) * vec2(1.0, 2.0 * PI);
    return h.x * vec2(cos(h.y), sin(h.y));
}

// Source: Karthik Karanth's blog
// https://karthikkaranth.me/blog/generating-random-points-in-a-sphere/#better-choice-of-spherical-coordinates
vec3 random_in_unit_sphere(inout float seed) {
    vec3 h = hash_3(seed) * vec3(2.0 * PI, 2.0, 1.0) - vec3(0.0, 1.0, 0.0);
    float theta = h.x;
    float sinPhi = sqrt(1.0 - h.y * h.y);
    float r = pow(h.z, 0.3333333334);

    return r * vec3(cos(theta) * sinPhi, sin(theta) * sinPhi, h.y);
}



struct Ray {
    vec3 origin, direction;
};

vec3 ray_at(Ray ray, float t) {
    return ray.origin + t * ray.direction;
}

Ray camera_get_ray(vec2 uv) {
    vec2 radius = camera.lensRadius * random_in_unit_disk(hashSeed);
    vec3 offset = camera.right * radius.x + camera.up * radius.y;
    vec3 lowerLeftCorner = camera.position - camera.horizontal*0.5f - camera.vertical*0.5f - camera.focusDistance*camera.backward;

    vec3 rayOrigin = camera.position + offset;
    vec3 rayDirection = lowerLeftCorner + uv.x*camera.horizontal + uv.y*camera.vertical - rayOrigin;

    return Ray(rayOrigin, normalize(rayDirection));
}



bool should_refract(in vec3 incoming, in vec3 normal, in float refractiveIndex, in float refractionRatio) {
    float cosTheta = min(dot(-incoming, normal), 1.0);
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
    // One troublesome practical issue is that when the ray is in the material with the higher refractive index,
    // there is no real solution to Snellâ€™s law, and thus there is no refraction possible--we must *reflect*.
    bool hasTotalInternalReflection = refractionRatio * sinTheta > 0.999;
    if (hasTotalInternalReflection) return false;

    // Use Schlick's approximation for reflectance. At steep angles, we should reflect instead of refract.
    float reflectance = (1.0 - refractiveIndex) / (1.0 + refractiveIndex);
    reflectance *= reflectance;
    float schlickApproximation = reflectance + (1.0 - reflectance) * pow(1.0 - cosTheta, 5.0);
    if (schlickApproximation > hash_1(hashSeed)) return false;

    return true;
}



struct Interval {
    float min, max;
};

struct HitRecord {
    vec3 position;
    vec3 normal;
    Material material;
    float t;
    float u;
    float v;
    bool isFrontFace;
};

void set_face_normal(in Ray ray, inout HitRecord record, in vec3 outwardNormal) {
    record.isFrontFace = dot(ray.direction, outwardNormal) < 0.0;
    record.normal = record.isFrontFace ? outwardNormal : -outwardNormal;
}



bool hit_sphere(in Ray ray, in Sphere sphere, in Interval t, inout HitRecord record) {
    vec3 relativeDir = ray.origin - sphere.center;
    float a = dot(ray.direction, ray.direction);
    float bHalf = dot(relativeDir, ray.direction);
    float c = dot(relativeDir, relativeDir) - sphere.radius*sphere.radius;
    float discriminant = bHalf*bHalf - a*c;

    if (discriminant < 0.0) return false;

    // Find the nearest root that lies in the acceptable range.
    float dSqrt = sqrt(discriminant);
    float root = (-bHalf - dSqrt) / a;
    if (!(t.min < root && root < t.max)) {
        root = (-bHalf + dSqrt) / a;
        if (!(t.min < root && root < t.max)) return false;
    }

    record.t = root;
    record.position = ray_at(ray, record.t);
    vec3 outwardNormal = (record.position - sphere.center) / sphere.radius;
    set_face_normal(ray, record, outwardNormal);
    record.material = sphere.material;

    return true;
}

// Source: DomNomNom / intersectAABB.glsl
// https://gist.github.com/DomNomNom/46bb1ce47f68d255fd5d
bool hit_aabb(in Ray ray, in AABB aabb, in Interval t) {
    vec3 invD = 1.0 / ray.direction;
    vec3 tMin = (aabb.min - ray.origin) * invD;
    vec3 tMax = (aabb.max - ray.origin) * invD;

    vec3 t0 = min(tMin, tMax);
    vec3 t1 = max(tMin, tMax);

    float tNear = max(max(max(t0.x, t0.y), t0.z), t.min);
    float tFar = min(min(min(t1.x, t1.y), t1.z), t.max);

    return tNear < tFar;
}



bool near_zero(in vec3 x) {
    const float epsilon = 1e-8;
    return abs(x.x) < epsilon && abs(x.y) < epsilon && abs(x.z) < epsilon;
}

// Source: Implementing a practical rendering system using GLSL - Toshiya Hachisuka
// https://cs.uwaterloo.ca/%7Ethachisu/tdf2015.pdf
bool hit_world(in Ray ray, in Interval t, out HitRecord record) {
    HitRecord tempRecord;
    BVHNode node;
    bool hasHitAnything = false;
    float tClosest = t.max;

    uint nextNodeIndex = 0; // Start at root of BVH
    while (nextNodeIndex != BAD_INDEX) {
        node = bvh[nextNodeIndex];

        if (hit_aabb(ray, node.aabb, Interval(t.min, tClosest))) {
            uint index = node.objectBufferIndex;
            bool isLeaf = index != BAD_INDEX;

            if (isLeaf && hit_sphere(ray, spheres[index], Interval(t.min, tClosest), tempRecord)) {
                hasHitAnything = true;
                tClosest = tempRecord.t;
                record = tempRecord;
            }

            nextNodeIndex = node.hitIndex;
        } else {
            nextNodeIndex = node.missIndex;
        }
    }

//    for (uint i = 0; i < camera.sphereCount; i++) {
//        if (hit_sphere(ray, spheres[i], Interval(t.min, tClosest), tempRecord)) {
//            hasHitAnything = true;
//            tClosest = tempRecord.t;
//            record = tempRecord;
//        }
//    }

    return hasHitAnything;
}

bool scatter(in Ray ray, in HitRecord record, inout vec3 attenuation, inout Ray scattered) {
    switch (record.material.type) {
        case MAT_LAMBERTIAN:
            vec3 scatterDirection = record.normal + random_in_unit_sphere(hashSeed);
            // Catch degenerate scatter direction
            if (near_zero(scatterDirection)) scatterDirection = record.normal;

            scattered = Ray(record.position, normalize(scatterDirection));
            attenuation = record.material.albedo;

            if (record.material.albedo == vec3(0.5)) {
                ivec3 uvFlat = ivec3(floor((1 / 0.32) * record.position));
                attenuation = ((uvFlat.x + uvFlat.y + uvFlat.z) % 2 == 0) ? vec3(0.2, 0.3, 0.1) : vec3(0.5);
            }

            return true;
        case MAT_METAL:
            float fuzziness = record.material.fuzziness;
            vec3 reflectDirection = reflect(ray.direction, record.normal);
            reflectDirection += fuzziness * random_in_unit_sphere(hashSeed);

            scattered = Ray(record.position, normalize(reflectDirection));
            attenuation = record.material.albedo;

            // Absorb rays that graze the surface of a sphere
            return dot(scattered.direction, record.normal) > 0.0;
        case MAT_DIELECTRIC:
            float refractionIndex = record.material.fuzziness;
            float refractionRatio = record.isFrontFace ? 1.0 / refractionIndex : refractionIndex;
            // Determine if the ray should be refracted or reflected
            vec3 refractDirection;
            if (should_refract(ray.direction, record.normal, refractionIndex, refractionRatio))
                refractDirection = refract(ray.direction, record.normal, refractionRatio);
            else
                refractDirection = reflect(ray.direction, record.normal);

            scattered = Ray(record.position, normalize(refractDirection));
            attenuation = vec3(1.0);

            return true;
        default:
            return false;
    }
}

vec3 ray_color(in Ray ray) {
    HitRecord record;
    vec3 attenuation;
    Ray scattered;
    uint depth;

    vec3 color = vec3(1.0);
    for (depth = 0; depth < MAX_BOUNCES; depth++) {
        // Return background if no hit occurs
        if (!hit_world(ray, Interval(0.001, INFINITY), record)) {
            float a = 0.5 * (normalize(ray.direction).y + 1.0);
            color *= mix(vec3(1.0), vec3(0.5, 0.7, 1.0), a);
            break;
        }

        // Return black if the ray was entirely absorbed
        if (!scatter(ray, record, attenuation, scattered))
            return vec3(0.0);

        ray = scattered;
        color *= attenuation;
    }

    return (depth == MAX_BOUNCES) ? vec3(0.0) : color;
}

void main() {
    vec3 cumulativeColor = imageLoad(outImage, ivec2(gl_GlobalInvocationID.xy)).xyz;
    vec3 passColor = vec3(0);

    for (uint s = 0; s < NUM_SAMPLES; s++) {
        vec2 uvOffset = hash_2(hashSeed);
        vec2 uv = vec2(gl_GlobalInvocationID.xy + uvOffset) / imageSize(outImage);
        Ray ray = camera_get_ray(uv);

        passColor += ray_color(ray);

        if (camera.shouldRenderAABB) {
            for (uint i = 0; i < camera.bvhSize; i++) {
                AABB aabbSrc = bvh[i].aabb;
                AABB aabbMod = AABB(aabbSrc.min + 0.005, -1, aabbSrc.max - 0.005);
                if (hit_aabb(ray, bvh[i].aabb, Interval(0.001, INFINITY)) && !hit_aabb(ray, aabbMod, Interval(0.001, INFINITY))) {
                    passColor = vec3(1.0);
                    break;
                }
            }
        }
    }
    passColor = passColor * (1.0 / NUM_SAMPLES);
//    passColor = sqrt(passColor); // sRGB gamma correction

    // If this is the first iteration of the scene, don't include the old cumulative color.
    if (camera.iteration != 1) passColor += cumulativeColor;

    imageStore(outImage, ivec2(gl_GlobalInvocationID.xy), vec4(passColor, camera.iteration));
}