#version 450

#define PI 3.14159265359
#define INFINITY 3.402823466e+38
#define NUM_SAMPLES 1
#define MAX_BOUNCES 4

layout (local_size_x = 16, local_size_y = 16) in;

layout (set = 0, binding = 0) uniform CameraParameters {
    vec4 from, at, up, cameraBackwards, cameraRight, cameraUp, lowerLeftCorner, horizontal, vertical;
    float lensRadius, iteration;
} camera;

layout (set = 0, binding = 1, rgba8) uniform image2D outImage;

struct Interval {
    float min, max;
};

bool interval_contains(Interval interval, float x) {
    return interval.min <= x && x <= interval.max;
}

bool interval_surrounds(Interval interval, float x) {
    return interval.min < x && x < interval.max;
}

float interval_clamp(Interval interval, float x) {
    return (x < interval.min) ? interval.min : (x > interval.max) ? interval.max : x;
}



// https://www.shadertoy.com/view/styBR1
float hashSeed = camera.iteration;

uint base_hash(uvec2 seed) {
    seed = 1103515245U * ((seed >> 1U) ^ (seed.yx));
    uint h32 = 1103515245U * ((seed.x) ^ (seed.y >> 3U));
    return h32 ^ (h32 >> 16);
}

float hash_1(inout float seed) {
    uint n = base_hash(floatBitsToUint(vec2(seed += 0.1, seed += 0.1)));
    return float(n) * (1.0 / float(0xffffffffU));
}

vec2 hash_2(inout float seed) {
    uint n = base_hash(floatBitsToUint(vec2(seed += 0.1, seed += 0.1)));
    uvec2 rz = uvec2(n, n * 48271U);
    return vec2(rz.xy & uvec2(0x7fffffffU)) / float(0x7fffffff);
}

vec3 hash_3(inout float seed) {
    uint n = base_hash(floatBitsToUint(vec2(seed += 0.1, seed += 0.1)));
    uvec3 rz = uvec3(n, n * 16807U, n * 48271U);
    return vec3(rz & uvec3(0x7fffffffU)) / float(0x7fffffff);
}

vec2 random_in_unit_disk(inout float seed) {
    vec2 h = hash_2(seed) * vec2(1.0, 2.0 * PI);
    return h.x * vec2(cos(h.y), sin(h.y));
}

// Source: Karthik Karanth's blog:
// https://karthikkaranth.me/blog/generating-random-points-in-a-sphere/#better-choice-of-spherical-coordinates
vec3 random_in_unit_sphere(inout float seed) {
    vec3 h = hash_3(seed) * vec3(2.0 * PI, 2.0, 1.0) - vec3(0.0, 1.0, 0.0);
    float theta = h.x;
    float sinPhi = sqrt(1.0 - h.y * h.y);
    float r = pow(h.z, 0.3333333334);

    return r * vec3(cos(theta) * sinPhi, sin(theta) * sinPhi, h.y);
}

vec3 random_unit_vector(inout float seed) {
    return normalize(random_in_unit_sphere(seed));
}


struct Ray {
    vec3 origin, direction;
};

vec3 ray_at(Ray ray, float t) {
    return ray.origin + t * ray.direction;
}

Ray camera_get_ray(vec2 uv, float seed) {
    vec2 radius = camera.lensRadius * random_in_unit_disk(hashSeed);
    vec3 offset = camera.cameraRight.xyz * radius.x + camera.cameraUp.xyz * radius.y;

    vec3 rayOrigin = camera.from.xyz + offset;
    vec3 rayDirection = camera.lowerLeftCorner.xyz + uv.x*camera.horizontal.xyz + uv.y*camera.vertical.xyz - camera.from.xyz - offset;

    return Ray(rayOrigin, normalize(rayDirection));
}



struct HitRecord {
    vec3 position;
    vec3 normal;
    float t;
    bool isFrontFace;
};

void set_face_normal(Ray ray, inout HitRecord record, vec3 outwardNormal) {
    record.isFrontFace = dot(ray.direction, outwardNormal) < 0.0;
    record.normal = record.isFrontFace ? outwardNormal : -outwardNormal;
}



struct Sphere {
    vec3 center;
    float radius;
};

bool hit_sphere(Ray ray, Sphere sphere, Interval t, out HitRecord record) {
    vec3 relativeDir = ray.origin - sphere.center;
    float a = dot(ray.direction, ray.direction);
    float bHalf = dot(relativeDir, ray.direction);
    float c = dot(relativeDir, relativeDir) - sphere.radius*sphere.radius;
    float discriminant = bHalf*bHalf - a*c;

    if (discriminant < 0.0) return false;

    // Find the nearest root that lies in the acceptable range.
    float dSqrt = sqrt(discriminant);
    float root = (-bHalf - dSqrt) / a;
    if (!interval_surrounds(t, root)) {
        root = (-bHalf + dSqrt) / a;
        if (!interval_surrounds(t, root)) return false;
    }

    record.t = root;
    record.position = ray_at(ray, record.t);
    vec3 outwardNormal = (record.position - sphere.center) / sphere.radius;
    //    set_face_normal(ray, record, outwardNormal);
    record.normal = outwardNormal;

    return true;
}

Sphere[] spheres = Sphere[2](
    Sphere(vec3(0, 0, -1), 0.5),
    Sphere(vec3(0, -100.5, -1), 100)
);

bool near_zero(vec3 x) {
    const float epsilon = 1e-8;
    return x.x < epsilon && x.y < epsilon && x.z < epsilon;
}

bool hit_world(Ray ray, Interval t, out HitRecord record) {
    HitRecord tempRecord;
    bool hasHitAnything = false;
    float tClosest = t.max;

    for (int i = 0; i < spheres.length(); i++) {
        if (hit_sphere(ray, spheres[i], Interval(t.min, tClosest), tempRecord)) {
            hasHitAnything = true;
            tClosest = tempRecord.t;
            record = tempRecord;
        }
    }
    return hasHitAnything;
}

vec3 ray_color(in Ray ray, vec2 seed) {
    const float attenuation = 0.5;

    vec3 color = vec3(1.0);

    HitRecord record;
    int depth;
    for (depth = 0; depth < MAX_BOUNCES; depth++) {
        if (hit_world(ray, Interval(0.001, INFINITY), record)) {
            vec3 scatterDirection = record.normal + random_unit_vector(hashSeed);

            if (near_zero(scatterDirection)) scatterDirection = record.normal;

            ray = Ray(record.position, scatterDirection);
            color *= attenuation;
        } else {
            float a = 0.5 * (normalize(ray.direction).y + 1.0);
            color *= mix(vec3(1.0), vec3(0.5, 0.7, 1.0), a);
            break;
        }
    }

    if (depth == MAX_BOUNCES) return vec3(0.0);

    return color;
}

void main() {
    vec3 originalColor = imageLoad(outImage, ivec2(gl_GlobalInvocationID.xy)).xyz;
    vec3 pixelColor = vec3(0);

    for (int s = 0; s < NUM_SAMPLES; s++) {
        vec2 uvOffset = hash_2(hashSeed);
        vec2 uv = vec2(gl_GlobalInvocationID.xy + uvOffset) / imageSize(outImage);

        pixelColor += ray_color(camera_get_ray(uv, s), uvOffset);
    }

    pixelColor = pixelColor * (1.0 / NUM_SAMPLES);
    if (camera.iteration != 1)
        pixelColor += originalColor;
    imageStore(outImage, ivec2(gl_GlobalInvocationID.xy), vec4(pixelColor, camera.iteration));
}